# this file should be executed and it's results sourced.
# such as: source <(cookbook/init sc ~/script_root $0)
# init will print the wrapper functions needed to bootstrap
# the sc function.
# 
# Bootstrapping the sc section requires two parts:
# 1. creating the function in question
# 2. wiring up tab completion for the function.
#
# functions must be used instead of a script, as
# cookbook also supports commands that modify the
# current environment (such as cd you into a specific)
# directory.
COOKBOOK_DIR=`dirname $0`
FUNCTION_NAME=$1
SCRIPT_ROOT=$2
COOKBOOK_EXECUTABLE=cookbook-linux
# not named SHELL because it would collide with 
# the shell environment variable.
SHELL_TYPE=$3
if [[ "$SHELL_TYPE" =~ "bash" || "$SHELL_TYPE" =~ "zsh" ]]; then
    echo "

    if [[ -n \${ZSH_VERSION-} ]]; then
        autoload -U +X bashcompinit && bashcompinit
    fi

    # completion is accomplished by thre parts:
    # 1. passing all possible completions to execute.py
    # 2. filtering for valid options using compgen
    # 3. appending to the valid option environment variable.
    function ${FUNCTION_NAME} {
        \`$COOKBOOK_DIR/$COOKBOOK_EXECUTABLE $SCRIPT_ROOT \$@\`
    }

    function _${FUNCTION_NAME}_completions {
        # we remove the first argument, which states the function name.
        # shift
        # next reverse the order of the arguments. for some
        # reason completion returns arguments in reverse order.
        cmd=\"$COOKBOOK_DIR/$SCRIPT_ROOT \${COMP_LINE:2} --complete\"
        all_options=\`$COOKBOOK_DIR/$COOKBOOK_EXECUTABLE $SCRIPT_ROOT \${COMP_LINE:2} --complete\`
        valid_options=\$(compgen -W \"\$all_options\" \"\${COMP_WORDS[COMP_CWORD]}\")
        COMPREPLY=(\$valid_options)
    }

    complete -F _${FUNCTION_NAME}_completions ${FUNCTION_NAME}

    ";
fi